Code Review
===========

We decided to do a code review of the recipe combination algorithm. The files we reviewed were MealScheduleFactory.rb, ScheduleBuilder.rb, and MealSchedule.rb, which are all under "app/models/". Most of the other code in our project has been modified by each person in the group at least once, so we all have too much exposure to it to do an accurate code review. The algorithm is the only significant portion of code that had only ever been touched by a couple of us. Bessie performed the review; she wasn't part of the back-end group that original designed the high-level algorithm, so she had to figure out what was going on from the code itself.

Results were generally positive. Despite it being her first exposure to the algorithm, Bessie figured out the recursive structure and fully understood the role of ScheduleBuilder in the process. All of the problems found were documentation problems save for one design problem.

In MealSchedule.collimated_schedule there was no explanation for why we picked the longest steps first on each iteration of the column-building loop. Fixing this required adding a single comment. Similarly, ScheduleBuilder didn't define what a schedule was in its description. Several of these small documentation changes are scattered throughout the reviewed files, especially in ScheduleBuilder. [This commit](https://github.com/zeamador/lattice-recipes/commit/f30d2e07bb605378422cda8de9658527c77838ef) (f30d2e07bb605378422cda8de9658527c77838ef) contains all of these changes.

ScheduleBuilder had some other more significant documentation issues. After reading through Bessie's comments, we realized that a lot of the knowledge we had from whiteboard diagrams and hours of design work wasn't reflected in the code. Outside eyes looking at the code had no hope of understanding *why* the code worked without recreating our whole design process. We started writing comments to try to convey this information, but realized there was just too much information to embed as text in the code. Instead, we made a document explaining high-level complexities of the algorithm and referenced it from the code. The document is currently in draft form, but the most important aspect of the algorithm to explain thoroughly is why adding steps preemptively works the way it does. As a developer-specific documentation pleasantry, we deicded having the explanation finalized for the release candidate was not a priority.

The other significant point of confusion was about a ScheduleBuilder's state. Bessie wasn't sure what information a ScheduleBuilder's "state" field and method conveyed, or why it was useful. We added a more verbose comment to the State class in ScheduleBuilder to attempt to solve this problem, but we discussed more significant changes. The code review made us question whether a ScheduleBuilder should know about its state at all, because the way we define State is specific to how we use ScheduleBuilder in MealScheduleFactory. We devised two ways to have MealScheduleFactory gather the data from ScheduleBuilder using more generic, less coupled interfaces, but decided for distinct reasons not to make either change. Some of the information currently stored in State is implementation-specific data; specifically, it stores a hash of preemptively scheduled steps. Our first solution involved exposing this data so that MealScheduleFactory could access it while a schedule was being built. This implementation exposure seemed to be a more serious problem than the current slightly bloated interface. The second solution was to use ScheduleBuilder's output schedule as its state. We implemented this approach prior to implementing States, and found its performance impact to be impractically severe. Getting the schedule from a ScheduleBuilder without exposing implementation details requires deep copying the internal schedule and reversing all of its keys. Additionally, a schedule typically has 2-10x more data points than its associated State, which proportionally slows down redundancy checks, which happen multiple times per node in the algorithm's recursive tree. We will continue to search for better solutions to this design problem, but for now we're shoring up the documentation and leaving it as-is.

More generally, we learned from the code review process how important it is as a group to pick a set of documentation guidelines and stick to them. One of the reasons Bessie could so easily navigate the code was because the comment structure was familiar; we've all been using it for weeks, so information is easy to find. We're also happy with the prevalence of inline comments laced through the code. The algorithm was difficult to write, so we wrote a lot of comments to understand it better ourselves. That turned out to be extremely beneficial both for a productive code review and in general for ease of navigation while making changes and looking for bugs.
